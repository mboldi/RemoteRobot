\documentclass[11pt,a4paper,oneside]{article}

%%%%%
% Márta Boldizsár
% 2021
% marta.boldi13@gmail.com
%%%%%

\usepackage{t1enc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage[thmmarks]{ntheorem}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{color}
\usepackage{lastpage}
\usepackage{anysize}
\usepackage[magyar]{babel}
\usepackage{sectsty}
\usepackage{setspace}  % Ettol a tablazatok, abrak, labjegyzetek maradnak 1-es sorkozzel!
\usepackage[hang,flushmargin]{footmisc}
\usepackage{textgreek}
\usepackage{url}
\usepackage{etoolbox}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{pifont}
\usepackage{makecell}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{caption}
\usepackage{newfloat}
\usepackage{subcaption}
\usepackage{threeparttable}
\usepackage{ifthen}
\usepackage{hyperref}
\def\UrlBreaks{\do\/\do-\do.\do\_}
\appto\UrlNoBreaks{\do\:}
\usepackage{bookmark}
\usepackage[nottoc]{tocbibind}

\definecolor{light-gray}{rgb}{0.9,0.9,0.9}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

%--------------------------------------------------------------------------------------
% Main variables
%--------------------------------------------------------------------------------------
\newcommand{\vikszerzo}{Márta Boldizsár}
\newcommand{\vikkonzulens}{Dr. Forstner Bertalan}
\newcommand{\vikcim}{Alacsony hálózati késleltetésre épülő AR megoldások telefonra és okosszemüvegre}
\newcommand{\viktanszek}{Automatizálási és Alkalmazott Informatikai Tanszék}
\newcommand{\vikdoktipus}{MSc Önálló laboratórium 1-2.}
\newcommand{\vikdepartmentr}{Márta Boldizsár}

%--------------------------------------------------------------------------------------
% Page layout setup
%--------------------------------------------------------------------------------------
\pagestyle{plain}
%\setlength{\parindent}{0pt} % áttekinthetőbb, angol nyelvű dokumentumokban jellemző
\setlength{\parskip}{4pt plus 3pt minus 2pt} % áttekinthetőbb, angol nyelvű dokumentumokban jellemző
\setlength{\parindent}{12pt} % magyar nyelvű dokumentumokban jellemző
%\setlength{\parskip}{0pt}    % magyar nyelvű dokumentumokban jellemző

\marginsize{35mm}{25mm}{15mm}{15mm} % anysize package
\setcounter{secnumdepth}{0}
\sectionfont{\large\upshape\bfseries}
\setcounter{secnumdepth}{2}
\singlespacing
\frenchspacing

%--------------------------------------------------------------------------------------
%	Setup hyperref package
%--------------------------------------------------------------------------------------
\hypersetup{
    bookmarks=true,            % show bookmarks bar?
    unicode=false,             % non-Latin characters in Acrobat’s bookmarks
    pdftitle={\vikcim},        % title
    pdfauthor={\vikszerzo},    % author
    pdfsubject={\vikdoktipus}, % subject of the document
    pdfcreator={\vikszerzo},   % creator of the document
    pdfproducer={TeXstudio, MiKTeX, PdfLaTeX, BibTeX},    % producer of the document
    pdfkeywords={VR, Unity, ROS, Robot Arm, UR5e},    % list of keywords
    pdfnewwindow=true,         % links in new window
    colorlinks=true,           % false: boxed links; true: colored links
    linkcolor=black,           % color of internal links
    citecolor=black,           % color of links to bibliography
    filecolor=black,           % color of file links
    urlcolor=black             % color of external links
}

%--------------------------------------------------------------------------------------
% Set up listings
%--------------------------------------------------------------------------------------
\DeclareFloatingEnvironment[fileext=locl,
listname={Kódrészletek jegyzéke},
name=kódrészlet,
placement=hbt,
within=section]{codelisting}

\setminted{bgcolor=light-gray,frame=lines,breaklines,fontsize=\footnotesize,tabsize=3}


%--------------------------------------------------------------------------------------
%	Some new commands and declarations
%--------------------------------------------------------------------------------------
\newcommand{\figref}[1]{\ref{fig:#1}.}
\renewcommand{\eqref}[1]{(\ref{eq:#1})}
\newcommand{\listref}[1]{\ref{listing:#1}.}
\newcommand{\sectref}[1]{\ref{sect:#1}.}
\newcommand{\tabref}[1]{\ref{tab:#1}.}
\newcommand{\listingref}[1]{\ref{listing:#1}.}

\newcommand{\afigref}[1]{\aref{fig:#1}.}
\newcommand{\aeqref}[1]{(\aref{eq:#1})}
\newcommand{\alistref}[1]{\aref{listing:#1}.}
\newcommand{\asectref}[1]{\aref{sect:#1}.}
\newcommand{\atabref}[1]{\aref{tab:#1}.}
\newcommand{\alistingref}[1]{\aref{listing:#1}.}

\newcommand{\Afigref}[1]{\Aref{fig:#1}.}
\newcommand{\Aeqref}[1]{(\Aref{eq:#1})}
\newcommand{\Alistref}[1]{\Aref{listing:#1}.}
\newcommand{\Asectref}[1]{\Aref{sect:#1}.}
\newcommand{\Atabref}[1]{\Aref{tab:#1}.}
\newcommand{\Alistingref}[1]{\Aref{listing:#1}.}

\definecolor{lightgray}{rgb}{0.95,0.95,0.95}

\author{\vikszerzo}
\title{\viktitle}
\includeonly{
	%guideline,%
	%project,%
	titlepage,%
	%declaration,%
	%abstract,%
	%chapter1,%
	%chapter2,%
	%chapter3,%
	%chapter4,%
	%chapter5,%
	%chapter6,%
	%acknowledgement,%
	%appendices,%
}

%--------------------------------------------------------------------------------------
%	Setup captions
%--------------------------------------------------------------------------------------
\captionsetup[figure]{width=0.8\textwidth, aboveskip=10pt}
\captionsetup[table]{width=0.8\textwidth, aboveskip=10pt}
\captionsetup[codelisting]{width=0.8\textwidth, aboveskip=3pt}
\captionsetup[sub]{labelformat=simple, labelsep=period}

\renewcommand{\captionlabelfont}{\small\bf}
\renewcommand{\captionfont}{\footnotesize\it}

\newcommand{\insertfig}[4]{
	\vspace*{2mm}
	\begin{figure}[#4]
		\center
		\resizebox{#3}{!}{\includegraphics{images/#1}}
		\parbox{0.8\textwidth}{\vspace*{4mm}\caption{{#2}}\small\label{fig:#1}}
	\end{figure}
	\vspace*{-2\parskip}
}

%--------------------------------------------------------------------------------------
%	Setup table of ... and related commands
%--------------------------------------------------------------------------------------
\makeatletter
\renewcommand*{\listof}[2]{%
	\@ifundefined{ext@#1}{\float@error{#1}}{%
		\expandafter\let\csname l@#1\endcsname \l@figure%
		\float@listhead{#2}%
		\begingroup
		\setlength\parskip{4pt plus 1pt}%
		\@starttoc{\@nameuse{ext@#1}}%
		\endgroup}}
\makeatother

\let\Chapter\chapter
\def\chapter{\addtocontents{locl}{\protect\addvspace{10pt}}\Chapter}

\begin{document}
\pagenumbering{roman}


\onehalfspacing
\include{titlepage}
\clearpage
\singlespacing

\tableofcontents

\clearpage
\singlespacing
\pagenumbering{arabic}

\section{A feladat leírása}

Az 5. generációs mobilhálózatok elhozták az alacsony kommunikációs késleltetés korát. Az egyik fontos alkalmazási területe ennek a különböző kiterjesztett valóság alkalmazásokon keresztül tálalt valósidejű információkra építő ipar, szórakoztató vagy egyéb információs alkalmazások.\footnote{A téma leírásából}

Rendkívül sok lehetőget tartogat magában egy olyan projekt, amely 5G-re és valamilyen kiterjesztett- vagy virtuális valóság technológiát használ. Látszik, hogy a jövőnek fontos része lesz ez a technológia, így hasznos, ha ismereteket szerzünk róla, ezért szerettem volna ezzel foglalkozni.

A feladatom egy olyan szoftverrendszer elkészítése lett, melynek segítségével távolról, 5G hálózaton keresztül lehet vezérelni egy robotkart VR környezetből, miközben kameraképen látja is a felhasználó, hogy mi történik a robot körül. Ez a rendszer számos konkrét felhasználásnak adhat alapot, többek között:
\begin{itemize}
  \item egy sűrűn berendezett gyáregységben lehetőséget nyújthat a robotkarok egyszerű konfigurálására, esetleg egyszerűbb hibák elhárítására anélkül, hogy közel kéne menjünk hozzájuk
  \item ha egy eszköz meghibásodik, akkor akár az azt telepítő cég mérnöke távolról, a gyár területén kívülről is tudja vizsgálni
  \item egy robotkar beállítása után lehetőséget adhat a robotkarral együtt végzett munka egyszerű kivitelezésére is, például félautomata selejtdetekció során a robotkar csak felemeli az adott vizsgálni kívánt terméket, majd a kezelő utasítására vagy tovább engedi a gyártási folyamaton, vagy selejtként kiszelektálja
\end{itemize}

A felhasználói felület esetében két használati mód, és ezzel együtt felület is van. Az egyik a konfigurációt végző személynek hasznos, itt be tudja állítani a robotkar általános pozícióit, esetleges határait, műveleteit. A másik mód mindennapi használatra alkalmas, ebben képes a kezelő felügyelni és utasítani a robotot működés közben.

A konkrét felhasználás, amire a feladat megoldást kíván adni, az futószalagon érkező termékek félautomata selejtdetekviója. Az érkező termékeket a robot kamerán keresztül felismeri, felemeli, majd egy kamerába megmutatva egy kezelő eldöntheti, hogy a termék hibás, vagy megfelelő minőségű.

Egy ilyen rendszer esetében rendkívül fontos, hogy minimális késleltetéssel rendelkezzen, hiszen nehéz úgy precízen poziciálni egy robotkart, ha másodpercek elteltével látjuk csak a mozgatási utasításunk eredményét. Erre kitűnő lehetőséget adnak az 5G hálózatok, ha megfelelő technológiákat használunk felette adatküldésre.

\newpage

\section{A használni kívánt technológiák vizsgálata}

Mint manapság bármilyen szoftverprojekt esetén, a szóban forgó témakörben is rengeteg lehetőség közül választhat egy architekt, illetve fejlesztő, hogy milyen technológiákat, keretrendszereket szeretne használni projektje során. Igyekeztem minél több lehetőséget vizsgálni, kipróbálni, és kiválasztani a számomra leginkább megfelelőt.

\subsection{Robotkar vezérlés}

A robotkar vezérléséhez a legkézenfekvőbb keretrendszer a ROS, vagyis a Robot Operating System\footnote{https://www.ros.org/} volt. A ROS egy nyílt forráskódú szoftvercsomag, amely hasznos fejlesztői eszközökkel, algoritmusokkal és driverekkel rendelkezik bármilyen robotokkal kapcsolatos projekt számára. A beépített moduljain kívül rendkívül sok kiegészítőt és csomagot lehet telepíteni hozzá. Tartalmaz minden olyan alapvető funkcionalitást, amely szinte minden robotvezérléshez szükséges, így nem kell mindenkinek ezeket megírni, illetve mivel sokan fejlesztik gyorsabb, hatékonyabb is lesz. Több, mint 10 éves múltja során hatalmasra nőtte magát a projekt, számos kutatási és oktatási projektben is jelen van.

A ROS-nak több verziója is van, én eleinte a ROS 1 Kinetic disztribúcióját használtam, mert azzal kompatibilis a konfigurációs csomag, mely szükséges volt az általam használt robotkarhoz. A ROS-ra épülve a MoveIt!\footnote{https://moveit.ros.org/} keretrendszert is használtam, mely egy absztrakciós szintet képezve lehetővé teszi, hogy a megfelelő konfiguráció és driver használata esetén ugyanazon vezérlő logika segítségével bármilyen fizikai kar vezérelhető legyen. Ezen kívül számos hasznos funkciót kínál még, amik könnyebbé teszik a fejlesztést, például a robotkar mozgásának tervezését, ütközésdetekciót és még sok mást.

\insertfig{ur5e}{A tanszéken is megtalálható UR5e robotkar}{6cm}{h!}

A projekt második félévének egyik első lépéseként átmigráltam a projektet ROS 1 Noetic verzióra, amivel a vezérlés hátterében futó operációs rendszert is ki kellett cserélni Ubuntu 20.04-re a korábbi Ubuntu 16-ról. A verzióváltás hátterében egyrészt az is állt, hogy a tanszéki robotkar mellett, annak vezérléséhez használt számítógépen mások által megtörtént ez a frissítés, de én is hasznosnak láttam. A továbbiakban részletezem még a hasznosságát, de talán az egyik legnagyobb különbség, hogy a Noetic verzió alatt már Python 3-at lehet használni, ami ideális, hiszen korábban a nyelv 2-es verziójához nem állt rendelkezésemre olyan csomag, ami hasznos lett volna.



A fejlesztéshez rendelkezésemre állt a tanszéken egy Universal Robots UR5e típusú robotkar, alapvetően erre fejlesztettem a rendszert. A MoveIt miatt viszont tulajdonképpen bármikor ki lehetne cserélni az eszközt.

A Moveit másik előnye, hogy lehetőséget ad arra, hogy egy szimulátorban működő robotkarral is ugyanúgy képes működni, mintha egy valódi eszköz lenne hozzákapcsolva. Annyit kell csak tenni, hogy a szimulátorral együttműködő drivert kell elindítani a fizikai karral kommunikáló helyett.

\insertfig{ur5e_sim}{Robotkar a szimulátorban}{6cm}{h!}

A robotkar megjelenítéséhez a Gazebo\footnote{http://gazebosim.org/} nevű szimulátort választottam, ebben lehetőség van a robot környezetének virtuális megépítésére is, illetve ugyanúgy lehet vezérelni benne a robotkart, mintha fizikai valójában lenne jelen. A vezérlés teszteléséhez az RVIZ\footnote{http://wiki.ros.org/rviz} használható, mely szoftverben láthatjuk akár azt amit a robot lát, illetve vizualizálhatjuk a robotnak szánt mozgások végrehajtását.

\insertfig{rviz}{Az Rviz felülete}{8cm}{h!}

A ROS programozására lehetőség van Python és C++ nyelven is. Én a Python mellett döntöttem, mert a későbbiekben szeretném gépi látással is bővíteni a projektet, amelyre megítélésem szerint tapasztalat nélkül alkalmasabb ez a nyelv. Főleg a Python 3, ami az újabb ROS-sal működik rengeteg lehetőséget rejt magában.

\subsection{Valós idejű vezérlés IP alapon}

Fontos része a rendszernek az irányítási parancsok, illetve metaadatok szinte valós idejű átvitele is. Ennek érdekében vizsgáltam több adatátviteli lehetőséget is. A három talán legelterjedtebb eszköz, melyeket találtam erre a célra az Apache Kafka, Apache Pulsar, illetve a RabbitMQ.

A Kafka\footnote{https://kafka.apache.org/} egy nyílt forráskódú elosztott esemény közvetítő platform, az Apache alapítvány 5 leginkább futó projektjeinek egyike. Beépített adatfolyam-feldolgozással rendelkezik, számos szolgáltatáshoz tud kapcsolódni és sok programozási nyelven dolgozhatunk fel segítségével eseményeket. Nagy átviteli kapacitással rendelkezik, akár 2 ms-os késleltetést is lehetséges elérni vele. Több ezer cég használja, ami bizonyítja megbízhatóságát.

A Pulsar\footnote{https://pulsar.apache.org/} egy szintén nyílt forráskódú, felhő-alapú elosztott üzenetküldő szolgáltatás, melyet kezdetben a Yahoo!-nál fejlesztettek ki, jelenleg ez is egy rendkívül fontos Apache projekt. A platform könnyen skálázható, számos programozási nyelvhez rendelkezik API-val és akár 5 ms-os késleltetés is lehetséges vele.

A RabbitMQ\footnote{https://www.rabbitmq.com/} az egyik legnépszerűbb nyílt forráskódú üzenetküldő bróker. Kis méretű, könnyen telepíthető akár felhőbe is. Több üzenetküldési protokollt is támogat, alapvetően AMQP-re épül. Üzenetsorok segítségével aszinkron üzenetküldést tesz lehetővé, webes felületén könnyen lehet monitorozni a rendszer forgalmát. Hasonlóan a fentebb ismertetett eszközökhöz, itt is lehetőség van számos kiegészítő telepítésére, melyek segítségével képes támogatni Continuous Integration mechanizmust, illetve integrálható más enterprise rendszerekkel.

\begin{table}
  \caption{Üzenetküldő szolgáltatások összehasonlítása}
  \label{table:compare_brokers}
  \begin{tabular}{l|c|c|c}
    & Kafka & Pulsar & RabbitMQ\\
    \hline
    \hline
    Maximális adatátvitel & 605 MB/s & 305 MB/s & 38 MB/s \\
    \hline
    Késleltetés & 5 ms & 25 ms & 1 ms\\
    & (200 MB/s terhelés) & (200 MB/s terhelés) & (30 MB/s terhelés)
  \end{tabular}
  A RabbitMQ átviteli sebessége 30 MB/s terhelés felett jelentősen csökkenni kezd.
\end{table}

Mint az \aref{table:compare_brokers}. táblázatban is látszik, a Kafka, illetve a Pulsar egy teszt során jelentősen nagyobb adatátvitelre képes, mint a RabbitMQ. Nekem azonban mivel nem tervezek nagy mennyiségű adatot átvinni, fontosabb az üzenet késleltetése, ami a RabbitMQ esetén a legkevesebb. A 4. generációs mobilhálózatok 200ms-os késleltetésével szemben az 5G-s hálózatokon akár 1 ms-ig is csökkenthető a látencia. Ennek kihasználására a tesztek alapján a RabbitMQ a legalkalmasabb.

A felsorolt technológiák közül a RabbitMQ-val találkoztam, azt korábban használtam már. Előfordulhat, hogy emiatti elfogultságom miatt, de valószínűleg a kutatásom során talált tényekre alapozva amellett döntöttem az alkalmazás üzenetküldéseinek kezelésére. További előnye a RabbitMQ brókernek, hogy futtatható Docker konténerként, ami nagyban megkönnyíti a telepítést.

\subsection{VR/AR megjelenítés}

A téma elején szeretném ismertetni, hogy eddigi életem során a legkomolyabb VR ,,élményt" egy Google Cardboard\footnote{https://arvr.google.com/cardboard/} jellegű VR szemüvegen éltem át, így sok tapasztalatom nincs ilyen berendezésekkel. A komolyabb VR szemüveg kipróbálásán kívül értelemszerűen nem is fejlesztettem még ilyen eszközre. Szerettem volna viszont megismerkedni velük, ezért is kezdtem bele ebbe a projektbe.

Ebben a témakörben az első, talán legfontosabb döntés, melyet meg kellett hozzak, hogy VR, vagy AR megjelenítést szeretnék. Mivel alapvetően távvezérlést szeretnék megvalósítani, ezért nincs feltétlen értelme a felhasználót körülvevő valóságot látni, így virtuális valóság mellett döntöttem a kiterjesztett valósággal szemben.

VR megjelenítésre több szemüveg közül lehet választani, azonban tervezési szempontból igazából mindegy, hogy melyiket szeretnénk a későbbiekben használni, hiszen a legtöbb fejlesztői környezet képes bármelyikre előállítani alkalmazást. Eltérés lehet a VR megjelenítőkhöz tartozó kézi irányítószervek között, igyekeztem azokat is megvizsgálni, melyik mire alkalmas. Végül én HTC Vive-ra terveztem megvalósítani a szoftvert, viszont végül a szemüvegen való kipróbálásig nem jutottam el a projektben.

Ezen alapvető kérdések eldöntése után már csak azt kellett eldöntsem, hogy milyen fejlesztői környezetben szeretném elkészíteni a VR-képes alkalmazást. Talán a két legnépszerűbb piaci szereplő ilyen célokra a Unity, illetve az Unreal Engine. A kettő közül a Unity a jobban elterjedt környezet VR fejlesztésekben. Alapjában véve egy játékmotor, viszont nem csak szórakoztató alkalmazásokat lehet készíteni benne. Hatalmas közösség van mögötte, rengeteg segítő dokumentum és könnyen letölthető asset áll rendelkezésre. A Unity talán legnagyobb ellenfele az Unreal Engine, amely szintén egy játékmotor, VR képességekkel. Az ő esetében is rendelkezésre áll számos letölthető erőforrás, a megjelenítése pedig valósághűbb tud lenni. Ez a keretrendszer fiatalabb, modernebb, mint a Unity, jobb teljesítményre képes.

Mivel egyik fejlesztői környezetet sem használtam még korábban, a tanulási görbéjük kutatásom szerint nagyjából azonos, viszont a Unity mögött nagyobb támogatottság áll VR fejlesztés terén, ezért azt választottam.

\subsection{Videójel továbbítása a robotkartól a vezérlő kliensbe}

Egy igen nagy feladat volt számomra a videó átviteli technológia kiválasztása a ROS-t futtató gép és a vezérlő kliens között. Ennek az esetében is rendkívül fontos, hogy minél gyorsabban jusson el a kép a felhasználó szeme elé.

Első ötletem egy RTMP stream volt, hiszen ezzel már találkoztam, igen elterjedt a videómegosztó platformokra történő streameléshez. Arra azonban nem gondoltam hirtelen, hogy ott nem fontos a késleltetés minimalizálása. Ez is lett a fő probléma ezzel az átviteli móddal, hiszen 10 másodperces késleltetés alá szinte lehetetlen levinni a közvetített videót. Emiatt ez teljesen alkalmatlan erre a felhasználásra, így más technológiák után kezdtem kutatni.

Eleinte a lehetséges átviteli technológiák közül a WebRTC-t, vagyis Web Real Time Communication-t választottam ki, mert azt találtam róla, hogy amellett, hogy szöveges üzeneteket lehet vele küldeni, rendkívül egyszerűen működik vele a videóátvitel is, nevéből is adódóan szinte valós időben. Azonban mivel Unity-ben szerettem volna működésre bírni, sajnos nem volt vele szerencsém a tesztelés során. Webes alapon sikerült megjelenítenem videóstreamet viszonylag gyorsan, viszont sajnos Unity-ne belül többszöri próbálkozás után sem épült fel a kapcsolat a videót streamelő fél és a Unity kliens között.

A viszonylag sok nem működő teszt közben felmerült az ötlet bennem, hogy akár NDI-on keresztül is lehetne videót átjátszani. Az NDI egy broadcast iparban feltörekvő IP alapú videótovábbító szabvány, mely produkciós környezetbe tervezettsége miatt kitűnő minőségű átvitelre képes. Arra a döntésre jutottam viszont, hogy az általa képviselt minőség miatti nagyjából 100-150 MB/s-os adatátvitele felesleges ebben az alkalmazásban. Ezen kívül nem tudom, hogy publikus hálózaton keresztül hogy működne, így elvetettem ezt az ötletet.

Az NDI megfontolása utáni további sikertelen RTC tesztek után jutottam el az RTP-hez. FFmpeg\footnote{http://www.ffmpeg.org/} segítségével könnyen tudtam készíteni egy teszt streamet egy videó segítségével, melyet a generált \textit{SDP} fájl minimális módosítása után le is tudtam játszani VLC media playerrel. Ez után már könnyen megvalósítható volt, hogy Unity-ben is megjelenjen a stream, hiszen létezik könyvtára és azt tudtam alkalmazni.

\subsubsection{WebRTC videó streamelés}

Az első félévben elvetettem a WebRTC-n történő videójel átvitelt, ami annak volt köszönhető főként, hogy nem tudtam megoldani, hogy Python-ból ebben a környezetben streameljek. Most azonban a ROS újabb verziójával kompatibilis Python3-hoz van olyan könyvtár, amely lehetővé teszi ezt, úgyhogy visszatértem ehhez a megoldáshoz.

A WebRTC mellett szól, hogy igen könnyen lehet webböngészőben is megjeleníteni belőle videót, hiszen főleg erre lett kifejlesztve, illetve gyorsabbnak mondják, mint az RTP-t, amit korábban használtam. Azzal nekem is az volt a tapasztalatom, hogy körülbelül egy-két másodperc eltelt aközött, hogy megmozdult a robot és, hogy láttam ezt a mozgást a videón is. Az én alkalmazásomban kritikus lenne a lehető legkisebb késleltetés, hiszen csak úgy lehet hatékonyan irányítani bármit, ha azonnal látjuk mi történik vele.

\insertfig{webrtc-architecture}{A WebRTC architektúrája}{12cm}{h!}

\Afigref{webrtc-architecture} ábrán látszik a WebRTC működési struktúrája:
\begin{enumerate}
  \item Első lépésként a videót küldeni kívánó partner elküld egy SDP leírót a fogadó félnek címezve, ekkor ő még nem tudja annak a címét, így szükség van egy signaling controller-re, amely továbbítani tudja az üzenetet.
  \item Ez után a fogadó fél megjegyzi a kapott információkat és generál rá egy választ, szintén egy SDP leírás formájában, amit a signaling serveren keresztül eljuttat a küldő félnek.
  \item Ekkor tulajdonképpen fel tud épülni a kapcsolat közöttük. Amennyiben NAT mögött vannak a felek szükség lehet STUN vagy TURN szerverekre, amelyek központi továbbítóként helyet foglalnak a két fél között, hiszen a NAT miatt közvetlen kapcsolat nem lenne lehetséges.
\end{enumerate}

Signalingra többféle megoldás közül lehet választani. A legegyszerűbb módja, ha valaki kézzel átmásolja az üzeneteket a két fél között, bár ez mindennapos használati környezetben érthető okokból nem kivitelezhető. Mivel a cél csupán annyi, hogy az üzenetek eljussanak bármilyen megbízható úton, tulajdonképpen bármit választhatunk, ami nekünk kényelmes. Lehet az egy TCP kapcsolat, vagy más.

Signaling szervernek én a már amúgy is használt RabbitMQ brókert választottam, abban definiáltam üzenetküldő sorokat, melyeken tudják a felek küldeni egymásnak a szükséges információkat. Annak érdekében, hogy az üzenetek a megfelelő félhez jussanak el, két sort definiáltam, egyet, melyen a küldő fél elküldi az offer-t, illetve egy másikat amelyen a vezérlő kliens - aki fogadni fogja a videót - válaszol. Ilyen módon elkülönül a kommunikáció iránya, és nem történhet meg véletlenül sem az, hogy az, aki elküldi az üzenet meg is kapja azt.


\subsection{A rendszer tervezett felépítése}

A techológiák kiválasztása után a következő felépítés alakult ki a terveimben:

\insertfig{felepites}{A rendszer tervezett felépítése}{12cm}{h!}

Mint az látható \afigref{felepites} ábrán, a felhasználói kliens a RabbitMQ brókeren keresztül kommunikál IP alapon a ROS-on belül található communicator ROS node-al. Ez továbbítja a beérkező üzeneteket a robotkar mozgatásáért felelő modulnak, illetve helyzetjelentést küld a kar állapotáról a kliensnek.

Ettől függetlenül történik a kamerakép streamelése a kliensnek IP alapon.

\newpage
\section{Megvalósítás}

\subsection{ROS}

Mivel alapvetően Windows operációs rendszert használok, eredetileg megpróbáltam erre telepíteni a ROS környezetet, viszont miután feltelepítettem sajnos nem működött rendesen. Mivel az Ubuntu az ajánlott operációs rendszer, ezért készítettem egy virtuális gépet, melyre Ubuntut, majd a ROS-t telepítve szerencsére működött a rendszer.

A ROS alap csomagok telepítése után elkészítettem a projekt alapját adó Catkin workspacet a megfelelő mappastruktúra kialakításával, majd a \textit{catkin\_make} parancs futtatásával. Ennek a könyvtárrendszernek a \textit{src} mappájába kell írjuk a forráskódunk, melyet szeretnénk futtatni ROS-on belül. Ebbe a mappába helyeztem el a robotkarhoz tartozó MoveIt konfigurációt is, melyet futtatni kell, hogy a vezérlése eljusson hozzá.

A robotkarhoz fontos, hogy megfelelő drivert használjunk. Több ilyet is kipróbáltam, mert változó kompatibilitással rendelkeznek ezek a csomagok. Az általam használt csomag eleinte a Githubon megtalálható \emph{Universal Robot}\footnote{https://github.com/ros-industrial/universal\_robot} volt, viszont mikor elkezdtem a fizikai robotkarral dolgozni rá kellett jöjjek, hogy azzal ez nem működik, ekkor tértem át az \emph{Universal Robots ROS Driver}\footnote{https://github.com/UniversalRobots/Universal\_Robots\_ROS\_Driver} csomagra. Mindkét csomag rendelkezik MoveIt! támogatással is és használhatjuk vele az Universal Robots számos karját. (A korábban használt csomag nem támogatja többek között a gyártó újabb, e-szériás robotkarjait, amilyen a tanszéki laborban is megtalálható.)


A ROS-on belül eleinte két fő node-ot valósítottam meg Python-ban, mint az \afigref{felepites} ábrán is látszik. Az egyik felelős az IP alapú kommunikáció feldolgozásáért és átfordításáért a ROS-on belülre. Tőle kapja meg a mozgatási információkat a másik fő modul, a robotkar mozgató komponens. Ő végzi a robottal való kommunikációt, utasítja, hogy hova mozogjon, és kiolvassa az állapotát is.

\insertfig{felepites_22tavasz}{A rendszer felépítése a 2022 tavaszi félév végén}{14cm}{h!}

\Afigref{felepites_22tavasz} ábrán látszódnak a fejlesztés közben kialakult új modulok, illetve az azok közötti kommunikáció. Az egyik legnagyobb változás a webes vezérlő megjelenése, amelyet \asectref{webclient} részben tárgyalok. Ezen kívül látszik, hogy hogy illeszkedik a rendszerbe az új videóküldő modul.

A feladat leírásában szerepel, hogy egy futószalagon érkező termékeket egy, a robotkar mellett elhelyezett kamerán keresztül lehet látni. Az első félév során ilyen szintre nem jutott el a fejlesztés, viszont a kamerakép továbbítását mindenképpen szerettem volna valamilyen módon helyettesíteni. Erre a célra akkor az ffmpeg segítségével egy képernyőképet továbbítottam a felhasználói kliens felé, mint az látható \afigref{unity_vezerles_robottal} ábrán.

A második félévben, mivel váltottam ROS Noetic disztribúcióra, át kellett álljak Python3-ra. Ez különösebben nagy változtatásokat nem igényelt az eddig megvalósított komponensekben, viszont új lehetőséget nyitott meg előttem. Már korábban is megtaláltam az \emph{aiortc}\footnote{https://github.com/aiortc/aiortc} Python könyvtárat, viszont használni nem tudtam a ROS kinetic Python2 kötöttsége miatt. Újabban viszont már bele tudtam építeni a rendszerbe és mivel kisebb késleltetést ígér a WebRTC az RTP-nél, meg is tettem. Ezzel a videóstreamelés is be tudott kerülni a ROS-on belül egy modulba, ami által jobban egy egységet képez a rendszer és a videós modul is tud kommunikálni a ROS ökoszisztéma többi tagjával, hogy például letiltsa a robot mozgását, ha megszűnik a videós kapcsolat, hiszen az igen veszélyes helyzetet tudna előidézni, ha a kezelő nem látja mit csinál, de a robot továbbra is végrehajtja az utasításait.

\subsection{Felhasználói kliens}

\subsubsection{VR/AR kliens}

Mint azt a tervek között is írtam, a kliensoldali alkalmazást, mely VR szemüvegen, annak kézi vezérlőivel kiegészítve kerül használatra, Unity környezetben készítettem. Korábban még nem használtam ezt a feljesztői eszközt, így eleinte nehézséget okoztak az alapvető feladatok is. Számos tesztalkalmazást készítettem különböző használni kívánt technológia kipróbálására, ezeknek a sikeres működése után kezdtem el elkészíteni a tényleges szoftvert.

Az alkalmazás design-ja jelenleg igen kezdetleges, mindenképpen szeretnék rajta még változtatni, illetve javában szükséges bővíteni is. Helyet kapott egy virtuális képernyő, melyen megjelenik a ROS felől érkező videójel. Emellett kaptak helyet az egyelőre gomb formájában megvalósult vezérlőszervek. Jelenleg csupán alapvető mozgatási parancsokat tudunk küldeni a robotkarnak, ez is bővülni fog a jövőben, viszont a tényleges vezérlést nem ilyen féle felülettel szeretném elkészíteni, hanem a VR szemüveghez tartozó kézi vezérlőkkel. Az ezek adta lehetőségeket kihasználva minél kevesebb hagyományos interakciós eszközt szeretnék használni, mint például gombokat.

\insertfig{unity_vezerles_robottal}{A felhasználói kliens felülete IP alapon fogadott videóképpel}{13cm}{h!}

\Afigref{unity_vezerles_robottal} ábrán látható az elkészült kliens felülete. Megvalósításra vár még a tervekben említett több futási mód, illetve szeretném a robot virtuális megjelenítését is, esetleg a környezetével együtt, így is megkönnyítve a kezelő munkáját, lehetővé téve neki, hogy mindig lássa a robotkar aktuális állapotát.

A videó fogadását a VLClib Unity alá készült verziója végzi, ami egy viszonylag nagyméretű vízjelet helyez el a képen. Ezt szeretném megoldani majd, hogy ne látszódjon, akár más fogadó könyvtár használatával.

\subsubsection{Webes kliens}\label{sect:webclient}

A korábbi fejlesztés során több új keretrendszert is meg kellett ismerjek egyszerre, úgy éreztem ez csökkenti a fejlesztés hatékonyságát, így megpróbáltam kizárni legalább egyet a teljesen ismeretlen platformok közül. Mivel eleinte inkább a robot vezérlésének összeépülésére szerettem volna koncentrálni, ezért úgy döntöttem a VR kliens és annak környezete, a Unity helyett készítek egy egyszerű webes vezérlőfelületet. Az elmúlt években több webalkalmazást is készítettem már, így abban kényelmesebben érzem magam, mint Unity alatt, ahol még semmit nem készítettem.

\insertfig{webclient-control}{A webes kliens vezérlő oldala}{13cm}{h!}

A kliens fő oldala a vezérlőfelület, ahol látjuk a robottól érkező videóképet, illetve tudunk neki üzeneteket küldeni. Ez a felület látható \afigref{webclient-control} ábrán. Lehetőség van a kar fejét több irányba mozgatni, forgatni a kart, illetve egy előre definiált home pozícióba való visszatérésre is tudjuk utasítani. Ez még mindig nem a megfelelő mennyiségű szabadsági fokkal rendelkező irányítás, ami a könnyű vezérléshez szükséges, de tesztelésre megfelelő. Kísérleteztem a félév során egy webkamerán keresztül a felhasználó kezét felismerő rendszer használatával, viszont annak a fejlesztése nem került olyan állapotba, hogy rendesen működjön.

A VR felülettel korábban probléma volt, hogy ha máshol futtattam a rendszer, akkor a változó IP címek miatt változtatnom kellett a forráskódot. Ez normális környezetben értelemszerűen nem kivitelezhető, így a webes kliens kapott egy beállítások oldalt, ahol meg tudjuk adni a ROS PC IP címét, amin elérhetővé válik számunkra. Ez a felület látszik \afigref{webclient-settings} képen. Itt a továbbiakban még más beállítási lehetőségek is meg fognak jelenni terveim szerint.

\insertfig{webclient-settings}{A webes kliens beállításokat tartalmazó felülete}{7cm}{h!}

A webes kliens feladata tehát leginkább az volt, hogy teszt jelleggel könnyebben tudjak küldeni vezérlő üzeneteket a ROS felé és tudjam tesztelni az onnan érkezőket. A használata közben rájöttem viszont, hogy bizonyos konfigurációs feladatokra valószínűleg praktikusabb, mint a VR környezet, így valószínűleg a későbbiekben is meg fogom tartani.


\subsection{Kommunikáció}

A kliens és a ROS közti kommunikáció RabbitMQ-n keresztül zajlik. Ehhez szükséges egy központi irányító szervert futtatni, ezt én Docker-ben tettem meg, hiszen rendkívül egyszerűen kezelhető így. Mivel szerencsére C\# és Python alá is rendelkezik könyvtárral, mellyel könnyen megoldható a kommunikáció, nem volt vele nagy gondom. \Afigref{rabbit_queue} ábrán is látható, hogy rendelkezik egy praktikus webes felülettel is, melyen nyomon lehet követni az üzenetsoraink állapotát.

\insertfig{rabbit_queue}{A RabbitMQ webes felülete}{14cm}{h!}

A webes kliens nem képes közvetlenül AMQP protokollon kapcsolódni a RabbitMQ szerverhez, így szükség volt arra is, hogy a Rabbit-et kiegészítsem egy pluginnal, amely WebSocket felett, STOMP protokoll segítségével is továbbít üzeneteket, amiket már tud fogadni a kliens.

A terveimet úgy készítettem el, hogy a különböző célú üzenetek más-más üzenetsorokban kerülnek küldésre. Ezek a sorok többek között:
\begin{itemize}
  \item \emph{robot-status}: itt küldi a ROS felőli oldala a rendszernek a robot állapotát kis időközönként
  \item \emph{move-robot}: itt megadhatunk egy (x, y, z) alakú vektort, amivel a robot fejét szeretnénk elmozgatni
  \item \emph{set-joints}: ebben a sorban lehet olyan üzenetet küldeni a ROS fele, amelyben a robot csuklóinak egy kívánt állapota szerepel
  \item \emph{webrtc}: WebRTC signalinghoz használt csatorna
  \item \emph{webrtc-resp}: WebRTC signalinghoz használt csatorna
\end{itemize}

Az alkalmazás selejtdetekcióra való használatához további üzenetcsatornák lesznek szükségesek, ezeknek a tervezését még nem véglegesítettem.

A ROS-on belül a saját topic alapú kommunikációját használtam. Többek között kerülnek átfordításra az IP alapon kívülről érkező csomagok is, egyéb szükséges kommunikáció is ezen keresztül zajlik a ROS node-ok között.

\subsection{Valós robotkar vezérlése}

A második féléves munka egyik nagyobb célja volt, hogy a szimulátoros tesztelés után a valós robotkar is megmozduljon.

\insertfig{robotkar-labor}{Az Universal Robots 5e robotkar a laborban}{10cm}{h!}

A legnagyobb akadályokat ebben is az okozta, hogy nem rendelkezem tapasztalattal ilyen területen, mindent fel kellett fedezzek és körül kellett járjak, mielőtt sikerült megvalósítanom. Az általam eredetileg használt, a szimulátorban működő driver a robotkarhoz nem volt megfelelő, így több verziót ki kellett próbáljak. Volt olyan driver is, amelynek buildelése során a catkin\_make hibával leállt, viszont később kiderült számomra, hogy az a megfelelő driver, csupán mivel korábban használtam egy régebbi verzióját, azért nem tudott lefutni és ha kitöröltem a korábban előállt futtatható állományokat, akkor már nem ütközött hibába.

A megfelelő driver kiválasztásával egyidőben ismerkedtem azzal is, hogy miként lehet kapcsolódni a robotkarhoz fizikailag, illetve hogy működik annak a saját vezérlője. A robot központi vezérlője és a ROS-t futtató számítógép egyszerű IP hálózaton keresztül kommunikálnak, ami jelen esetben csupán egy, a két eszközt összekötő UTP kábel. A robothoz tartozik egy kézi vezérlő egység is, ezen keresztül lehet konfigurálni, illetve saját programokat készíteni rá. Mivel ez a robotkar egy kollaboratív robot, a megfelelő opció kiválasztása után kézzel is lehetőség van mozgatni a kart egy kívánt pozícióba. A kézi egység érintőkijelzőjén megjelenő gombokkal lehetőség van manuálisan is mozgatni a kart, hasonlóan ahhoz a rendszerhez, melyet én készítettem, csupán ennek az esetében korlátozza a vezérlő személy hollétét az egységet és a robotkart összekötő kábel hossza.

\insertfig{robot-vezerlo}{A robotkarhoz tartozó kézi vezérlő egység}{8cm}{h!}

Több a robotkarhoz való sikertelen kapcsololódás után derült ki számomra, hogy nem megfelelően próbáltam elérni ezt a célt, ugyanis a kar vezérlőjén el kell indítani egy programot, amely felépíti a kapcsolatot a robot és a számítógépen futó vezérlés között. Miután ezt is megfelelően csináltam, már működött is a vezérlés az én rendszerem által. Tudtam vezérelni a kart és kaptam tőle visszajelzést is az állapotáról, a csuklók pozíciójáról.


\newpage
\section{Összefoglaló gondolatok}

Azt gondolom, hogy 1 év alatt, amióta ezt a projektet csinálom, jelentősen nagyobb előrehaladás is elérhető lett volna, ha rendelkezem tapasztalattal a releváns területeken. Nagyjából minden, amit használtam a rendszer összeállításához, a ROS, a Unity, kis késleltetésű videóstreamelés, maga a robotkar, de Pythonnal, Ubuntuval se foglalkoztam sokat korábban. Mivel nem egy mindennapi, bárki által otthon is fejleszthető alkalmazás a robotika, jelentősen kevesebb leírás, erőforrás áll rendelkezésre is az interneten ebben a témakörben.

Rendkívül sok új technológiát ismertem meg a rendszer fejlesztése során. A használt eszközök nagyon szerteágazók, a robotikán kívül sokat kellett foglalkozzak még más olyan területekkel is, amelyek számomra nem voltak egyértelműek, rendkívül sokat kellett utánaolvassak dolgoknak. Nagyon nehéz volt számomra úgy fejleszteni egy rendszert, hogy ha megcsináltam sok próbálkozás után egy részét, akkor a következő részénél is ugyanúgy majdnem minden lépést sok kutatás kellett megelőzzön, nem volt egy biztos pontja, amit jól ismertem. (Ezért döntöttem a második félév elején a webes irányítás elkészítése mellett, amelynek szintén voltak olyan részei, amihez hasonlót korábban még nem csináltam.)

A második félév alatt összességében sajnos nem jutott annyi időm a rendszer fejlesztésére, amennyit szerettem volna eleinte, de remélem, hogy be fogok tudni pótolni az elmaradást.

\newpage
\section{További tervek}

A rendszer egy éves munkám alatt eljutott egy olyan fázisba, hogy lehet a robotkart távolról vezérelni és a vezérlő felületen láthatunk egy élő videóképet róla. Nagyon sok időm ment el arra, hogy megismerjem a használni kívánt technológiákat és megfelelő módon kezdjem el használni őket. A jelenlegi állapot már azt gondolom egy jó alap annak, hogy meg tudjam kezdeni a konkrétabb alkalmazások ráépítését és, hogy ki tudjam dolgozni a kezdetekkor megálmodott VR/AR alapú vezérlést is.

Jelenlegi konkrét fejlesztési terveim nagy vonalakban a következők:
\begin{itemize}
  \item A videóátvitel optimalizálása, gyorsítása.
  \item Kliensalkalmazás kibővítése rengeteg tervezett funkcióval, többek között:
  \begin{itemize}
    \item Konfigurációs és kezelői mód különválasztása
    \item Virtuális robot megjelenítése, amely tükrözi a valósat
    \item VR rendszerhez tartozó kézivezérlők alkalmazása irányításra
  \end{itemize}
  \item Gépi látással való foglalkozás, hogy a robotkar alapvető mozdulatokat végre tudjon hajtani magától
\end{itemize}



\end{document}
